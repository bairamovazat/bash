htop - текущая нагрузка
$$ - ид текущего процесса
--------------------------------------------------------------------------------


/ - экранирует символы
'' - одинакрые ковычки - баш внутри ничего не меняет. Выдаёт как есть. Нельзя внутри использовать '. $'\t'
"" - двойные кавычки - может делать подстановки
`` - апостроф - всё, что внутри запускается в отдельном баше (echo "Время `date` сейчас")
$\` - на эти символы реагирует bash и выполняет подстановки

$"string-key" - используется для локализации. Ка 
reset - сбрасывает терминал

bash -D test.sh

ctrl + d - завершение файла
ctrl + c - прерывание команды. Линукс перехватывает вызов и посылает команду kill (sigterm)
ctrl + z - sigstop. Можно поставить на паузу и потом запустить.

/dev/zero - генирирует всегда нули
/dev/null - можно туда посылать что-то

ps, htop - запущенные программы

kill -USR1 3409 - отправка комнды процессу 3409

ps -aux | less - выводит все процессы. tty - принадлежность к текущему терминалу


--------------------------------------------------------------------------------


echo {1,2}-dir -> 1-dir 2-dir
echo {1..4} -> 1 2 3 4
echo {1..5..2} -> 1 3 5

Подстановка команд - очень дорогостоющая 
CURDATE=$(date)
CURDATE=`date`

Арифметические вычиления $(( expr )) 
!!!Пробел обязятелен!!!

--------------------------------------------------------------------------------

Переменные

VAR1=5 - присвоение
echo $VAR1 - 5
echo ${VAR1} - 5

unset - сбрасывание переменной
declare - задавание атрибутов

alias ttt="echo ttt" - задаёт псевдоним для команды 
declare -r PI=3.14 - задаём перменную с атрибутом -r (readonly)
export VAR=123 - передаются переменные в дочерние процессы
readonly VAR=123 - readonly
local VAR=123 - локальные перменные в функциях

Параметры для declare:
declare -a A - индексный массив 
A[0]=10 - задали значение массива с индексом 0
A[5]=50 - задали значение массива с индексом 0

echo ${A[0]} - 10
echo "${A[*]}" - 10 50 - это одно слово
echo "${A[@]}" - 10 50 - это два слова

echo "${#A[@]}" - 2 - кол-во элементов в массиве
echo "${#A[*]}" - 2 - кол-во элементов в массиве

echo "${!A[@]}" - 0 5 - индексы
echo "${!A[*]}" - 0 5 - индексы

unset A[5] - удаление элемента

B=(10 20 56 67 [70]=Test "Test 123")
declare -p B - вывод данных о массиве


declare -A Y - ассоциативный массив (ключ - текст)
Y[a]=10
Y[b]=20
Y[c]=50


declare -i M N Z - целочисленные перменные
M=2
N=3
Z=M+N
echo $Z - 5

declare -l u - все символы в нижнем регистре

declare -u U - все символы в верхнем регистре

a=1
declare -n ga=a - ссылка на переменную
echo $ga - 1

--------------------------------------------------------------------------------

Позиционные параметры

$1 - первый переданный параметр
${10} - второй переданный параметр
$# - кол-во параметров

$* - вывести все параметры одним словом
$@  - вывести все параметры разными словами
shift N - смещение на N параметров назад (влево) 2 -> 1

IFS - разделитель по умолчанию при использовании $@ или $* в кавычках (мб ещё где)

Специальные параметры 
* @ # ? - $ ! 0
$? - статус последнего процесса
$- - флаги с которыми была выполнена команда set последний раз
$$ - pid процесса 
$! - последний фоновый процесс
$0 - название текущего скрипта

${param:[-=?+]word} 
echo ${a:-defaultValue} - выводит либо a (если есть значение), либо defaultValue
echo ${a:=defaultValue} - выводит и присваивает 
echo ${a:?Test error message} - проверяет переменную a. Если переменная не задана, то выходит ошибка и завершается скрипт 
echo ${a:+test} - если а есть, то выводится подстановочное слово test

a=0123456789abcdef
${a:7} - сдвигает курсор от начала на 7 позиций правее и выводит всё что правее(обрезает слева 7 символов)

${a:7:2} - сдвигает и оставляет 2 символа
9a
${a: -7:-2} - сдвигает курсор с конца на 7 позиций левее и выводим всё что правее
9abcd

Аналогично можно работать с массивами

${param} - значение параметра 
		 -> позиционные ${12}
		 -> специальные ${[#!]var[*@]}
		 	# - кол-во элементов
		 	! - 

--------------------------------------------------------------------------------

Управляющие конструкции
циклы - until while for

for:
for name [ [in [words ...]] ; ] do commands; done
есть есть in, то words раскрывается по всем правилам. Далее переменная name принимает набор команд. По емолчанию, если не указывать in word принимает параметр "$@" - т.е. все параметры запущенного скрипта

while:
while test-command; do command; done
выполняется пока test-command возвращает 0

until:
until test-command; do command; done
выполняется пока test-command возвращает НЕ 0

if:
if [-f $1]

if test-commands; then
	commands;
elif second-test-commands; then
	second-commands;
else 
	alternative-commands;
fi

существуют команды true и false и :

case:
*!?[]
case $1 in
a*) echo option a;;
b) echo option b;;
[cd]) echo option b;;
esac	


select:
Выбор меню
select choise in play stop pause; 
do echo $choise;
done

[[]] - логические выражения

--------------------------------------------------------------------------------

/etc/passwd

read var - комманда, которая читает данные и складывает в переменную var

${var%.txt} - удалять конец файла (.txt)

--------------------------------------------------------------------------------

Ввод ввывод. Дескрипторы.

У процесса всегда есть 3 дескриптора 0 - ввод 1 - вывод 2 - ошибка.

Перенаправление выхода (Замещение стандартных дескрипторов)
echo "Hello" 1>out.txt 2>error.txt
echo "Hello" >out.txt

Перенаправление входа (Замещение стандартных дескрипторов)
cat <input.txt
: >newfile.txt - создание нового файла

echo "Hello" >out.txt - создаёт и записывает hello в файла (если были данные, то они стираются)
echo "Hello" >>out.txt - добавляет данные в файл

echo "Hello">& 60- отправка в другой дескриптор
КОНВЕЕР
Базымянный pipe
выход этого -> идёт как вход сюда
cat /etc/passwd | sort -t: -k4 -g

переопределение вывода
cat <<EOF
data bla
bla-bla
$variable
EOF

exec 1>newout.txt - перенаправление для всех файлов далее
exec 10<>in.txt - открывает файл на чтение и запись с дескриптором 10
exec 10>&- - закрытие дескриптора

--------------------------------------------------------------------------------

ФУНКЦИИ

redirections перенаправление ввода вывода 
fname () commands [ redirections ] 
function fname [()] commands [ redirections ]

function func1 {
	
}

. mylib.sh | source mylib.sh - подключение файла как "библиотеки". Bash подставляет всё из файла в это место.

func1 123 - вызов функции из файла mylib

result=$(func1 arg1)

Передача массива в функцию

function printarray {
	arr=$1
	echo "${arr[@]}"
}

a=(a b c d e)

printarry ${a[@]}

КОМАНДЫ
команды бывают:
обычные - /usr/bin/bc
aliase - 
функции -
внутренние команды -

--------------------------------------------------------------------------------

Запуск процесса в фоновом режиме 

dd if=/dev/urandom of=test.img &

jobs - список запущеных задач
+ - предыдущее
- - до предыдущего
без символа - ещё ранее

jobs -n - изменённые статусы с последнего вызова
jobs -p - просмотреть пиды 
Ctrl + Z - sigstop процессу на пререднем фоне

bg 4 - запускает 4 задачу в фоновом режиме

fg 4 - выводит 4 задачу на передний план и запускает, если не запущена

kill process_id - убить процесс

%2 - аналог fg 2

%+ (или %) - аналог fg для последнего задания

Группировка команд:
(sleep 5 ; read a; echo $a) &
{ sleep 5 ; read a; echo $a; } &

sudo apt install parallel - утилита для параллельных вычислений

